(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{371:function(e,t,s){e.exports=s.p+"assets/img/mvc.6cc1225d.png"},372:function(e,t,s){e.exports=s.p+"assets/img/mvp.142faa3e.png"},373:function(e,t,s){e.exports=s.p+"assets/img/mvvm.d0abf9ab.jpg"},475:function(e,t,s){"use strict";s.r(t);var i=s(45),o=Object(i.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"view-architecture"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#view-architecture"}},[e._v("#")]),e._v(" View Architecture")]),e._v(" "),i("p",[e._v('When talking about "view architecture", what we are referring to is how the the "User interface" part of the codebase interacts with the business logic and data recovery parts. While in theory it is entirely possible to code your entire application in one class file (check out of the files from the '),i("a",{attrs:{href:"https://raw.githubusercontent.com/DrKLO/Telegram/master/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Telegram app"),i("OutboundLink")],1),e._v("), it is considered best practice to split into multiple files the code responsible for displaying a view.")]),e._v(" "),i("p",[e._v("For instance, an overly simplified version of this is to have:")]),e._v(" "),i("ul",[i("li",[e._v("one class which handles loading and updating UI elements")]),e._v(" "),i("li",[e._v("one class which waits for specific events (i.e. view needing to load for the first time, or the user clicking a button), applies the necessary business logic, and tells the other class what needs to happen")])]),e._v(" "),i("p",[e._v("Something like this also helps to apply SOLID principles:")]),e._v(" "),i("ul",[i("li",[e._v("(S) - each class only has a specific job to do")]),e._v(" "),i("li",[e._v("(O) & (L) - communication between the two classes is usually done via interfaces, the implementation of which is not important to the other class")]),e._v(" "),i("li",[e._v("(I) - ideally, the interfaces between the two classes contain the bare minimum of methods required for communication, with nothing superfluos between them")]),e._v(" "),i("li",[e._v('(D) - all of this helps to ensure as loose a coupling as possible between the "UI" class and the "Logic" class. The added benefit of this is that if we want to unitarily test either of the layers, we can replace the other layer with a mocked version which provides all the test values we require to exhaustively test out our code')])]),e._v(" "),i("p",[e._v("Let's quickly go over some of the common view architecture paradigms which are common in Android development:")]),e._v(" "),i("h2",{attrs:{id:"mvc-model-view-controller"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#mvc-model-view-controller"}},[e._v("#")]),e._v(" MVC - Model - View - Controller")]),e._v(" "),i("p",[i("img",{attrs:{src:s(371),alt:"MVC"}})]),e._v(" "),i("p",[e._v("In the MVC pattern, we distinguish:")]),e._v(" "),i("ul",[i("li",[e._v("The "),i("strong",[e._v("View")]),e._v(" - this refers to the XML layouts, as well as the UI component custom classes, responsible for the actual UI rendering")]),e._v(" "),i("li",[e._v("The "),i("strong",[e._v("Controller")]),e._v(" - this refers to the Activies and Fragments of your app, responsible for the application logic, responding to user interaction, and updating the Model")]),e._v(" "),i("li",[e._v("The "),i("strong",[e._v("Model")]),e._v(" - this refers to the layer which handles and stores application data, implements business rules, and communicates with the data layer (e.g. databases, network calls)")])]),e._v(" "),i("p",[e._v("The data flow between the 3 components does not enforce strict limits, and is usually circular and bi-directional:")]),e._v(" "),i("ul",[i("li",[e._v("The "),i("strong",[e._v("View")]),e._v(" can inform both the "),i("strong",[e._v("Controller")]),e._v(" and the "),i("strong",[e._v("Model")]),e._v(" of events")]),e._v(" "),i("li",[e._v("The "),i("strong",[e._v("View")]),e._v(" can receive instructions from the "),i("strong",[e._v("Controller")]),e._v(", but also in some cases directly from the "),i("strong",[e._v("Model")])]),e._v(" "),i("li",[e._v("The "),i("strong",[e._v("Model")]),e._v(" can get updated by both the "),i("strong",[e._v("Controller")]),e._v(" and the "),i("strong",[e._v("View")])])]),e._v(" "),i("p",[e._v("This lack of strictness means that it can get hard to pinpoint a single source of truth when trying to determine what the UI state should be - in practice it happens that all 3 layers contribute something to the state of the UI, with default elements from the "),i("strong",[e._v("View")]),e._v(", app logic applied from the "),i("strong",[e._v("Controller")]),e._v(" independantly of any other business rules, and data coming in from the "),i("strong",[e._v("Model")]),e._v(" layer.")]),e._v(" "),i("p",[e._v("This architectural pattern is considered obsolete for Android development currently, and usually has already been replaced by one of the following patterns")]),e._v(" "),i("h2",{attrs:{id:"mvp-model-view-presenter"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#mvp-model-view-presenter"}},[e._v("#")]),e._v(" MVP - Model - View - Presenter")]),e._v(" "),i("p",[i("img",{attrs:{src:s(372),alt:"MVP"}})]),e._v(" "),i("p",[e._v("In the MVP pattern, we distinguish:")]),e._v(" "),i("ul",[i("li",[e._v("The "),i("strong",[e._v("View")]),e._v(' - this refers to the UI layer as a whole, the XML layouts, the custom UI component classes, and the Activities and Fragments. In this pattern, the "intelligence" of this layer is limited to only calling a method of the '),i("strong",[e._v("Presenter")]),e._v(" when there is an interface action (UI or lifecycle driven)")]),e._v(" "),i("li",[e._v("The "),i("strong",[e._v("Presenter")]),e._v(" - this refers middle-man layer between the "),i("strong",[e._v("View")]),e._v(" and the "),i("strong",[e._v("Model")]),e._v(". It retrieves data from the Model and returns it formatted to the View. But unlike the typical MVC, it also decides what happens when you interact with the View")]),e._v(" "),i("li",[e._v("The "),i("strong",[e._v("Model")]),e._v(" - as for MVC, this refers to the layer which handles and stores application data, implements business rules, and communicates with the data layer (e.g. databases, network calls)")])]),e._v(" "),i("p",[e._v("The data flow between the 3 components in this pattern is more strictly enforced compared to MVC. We thus have:")]),e._v(" "),i("ul",[i("li",[e._v("The "),i("strong",[e._v("View")]),e._v(" interacts only with the "),i("strong",[e._v("Presenter")]),e._v(", sending out events and receiving instructions about how to update itself")]),e._v(" "),i("li",[e._v("The "),i("strong",[e._v("Model")]),e._v(" is only ever called by the "),i("strong",[e._v("Presenter")]),e._v(", when data is required")]),e._v(" "),i("li",[e._v("The "),i("strong",[e._v("Presenter")]),e._v(" interacts with both the "),i("strong",[e._v("View")]),e._v(" (receiving calls, and sending updates) and the "),i("strong",[e._v("Model")]),e._v(" (requesting data, and in some cases getting updates spontaneously from it - usually from background tasks")])]),e._v(" "),i("p",[e._v("Compared to MVC, we can see that this pattern improves upon the responsability for the state of the UI, with the "),i("strong",[e._v("Presenter")]),e._v(" being the sole responsible for updating the "),i("strong",[e._v("View")]),e._v(", based upon its own and the "),i("strong",[e._v("Model's")]),e._v(" rules.")]),e._v(" "),i("p",[e._v("However, a big drawback of this pattern is that it increases the coupling between the "),i("strong",[e._v("View")]),e._v(" and the "),i("strong",[e._v("Presenter")]),e._v(". The "),i("strong",[e._v("Presenter")]),e._v(" has to provide explicit methods to be called by the "),i("strong",[e._v("View")]),e._v(", and conversely the "),i("strong",[e._v("View")]),e._v(" provides methods so that it can get updated. This is mitigated by using interfaces for at least the "),i("strong",[e._v("View")]),e._v(" if not for the "),i("strong",[e._v("Presenter")]),e._v(" as well, but the issue remains that the "),i("strong",[e._v("Presenter")]),e._v(" has to know what the "),i("strong",[e._v("View")]),e._v(' "looks" like and it is not easy to reuse a presenter for a different view.')]),e._v(" "),i("p",[e._v("While not state of the art, this pattern can still be found on some legacy projects. In order to address the coupling issue, the following patterns have been proposed")]),e._v(" "),i("h2",{attrs:{id:"mvvm-model-view-view-model"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-model-view-view-model"}},[e._v("#")]),e._v(" MVVM - Model - View - View Model")]),e._v(" "),i("p",[i("img",{attrs:{src:s(373),alt:"MVVM"}})]),e._v(" "),i("p",[e._v("In the MVP pattern, we distinguish:")]),e._v(" "),i("ul",[i("li",[e._v("The "),i("strong",[e._v("View")]),e._v(" - as in MVP, this refers to the UI layer as a whole, the XML layouts, the custom UI component classes, and the Activities and Fragments. Similar to MVP, this layer is limited to sending events (user or lifecycle driven) to the "),i("strong",[e._v("View-Model")]),e._v(", and updating when the "),i("strong",[e._v("View-Model")]),e._v(" tells it to. The difference is that, whereas in MVP the "),i("strong",[e._v("Presenter")]),e._v(" had to call explicit methods on the "),i("strong",[e._v("View")]),e._v(", for "),i("strong",[e._v("MVVM")]),e._v(" it is the "),i("strong",[e._v("View")]),e._v(" which subscribes to a data flow provided by the "),i("strong",[e._v("View-Model")]),e._v('. The "intelligence" of this layer is limited to only calling a method of the '),i("strong",[e._v("Presenter")]),e._v(" when there is an interface action (UI or lifecycle driven)")]),e._v(" "),i("li",[e._v("The "),i("strong",[e._v("View-Model")]),e._v(" - this refers middle-man layer between the "),i("strong",[e._v("View")]),e._v(" and the "),i("strong",[e._v("Model")]),e._v(". Similar in function to MVC or MVP, it retrieves data from the Model and returns it formatted to the View. However, the way this is done is by providing a flow of data to which the "),i("strong",[e._v("View")]),e._v(" will subscribe to, and posting events to that flow. This has the advantage of further decoupling the "),i("strong",[e._v("View")]),e._v(" and the "),i("strong",[e._v("View-Model")]),e._v(", and removing the obligation of implementing interface methods which might be unnecessary when trying to reuse "),i("strong",[e._v("View-Models")]),e._v(" between different "),i("strong",[e._v("Views")])]),e._v(" "),i("li",[e._v("The "),i("strong",[e._v("Model")]),e._v(" - as for MVC, this refers to the layer which handles and stores application data, implements business rules, and communicates with the data layer (e.g. databases, network calls). In contrast to MVP and, in part, because of the way the "),i("strong",[e._v("View")]),e._v(" subscribes to the "),i("strong",[e._v("View-Model")]),e._v(" in a reactive way, the model as well tends to be implemented following reactive programming principles (i.e. providing a flow of data to which a receiver will subscribe, instead of just directly returning the data to the method caller)")])]),e._v(" "),i("p",[e._v("The data flow between the 3 components in this pattern is a further refinement of MVP, with the added notions of reactive programming being ingrained in the pattern itself. We thus have:")]),e._v(" "),i("ul",[i("li",[e._v("The "),i("strong",[e._v("View")]),e._v(" interacts only with the "),i("strong",[e._v("View-Model")]),e._v(", sending out events and registering an observer to await events from the "),i("strong",[e._v("View-Model")]),e._v(" about how to update itself")]),e._v(" "),i("li",[e._v("The "),i("strong",[e._v("Model")]),e._v(" is only ever called by the "),i("strong",[e._v("View-Model")]),e._v(", when data is required. In most cases, the data is returning asynchronously and usually involves the same observable <> observer principle.")]),e._v(" "),i("li",[e._v("The "),i("strong",[e._v("View-Mdoel")]),e._v(" interacts with both the "),i("strong",[e._v("View")]),e._v(" (receiving calls, and sending updates) and the "),i("strong",[e._v("Model")]),e._v(" (requesting data, and  getting updates asynchronously)")])]),e._v(" "),i("p",[e._v("Compared to MVC & MVP, we can see that this pattern further improves upon the responsability for the state of the UI, with the "),i("strong",[e._v("View-Model")]),e._v(" being the sole responsible for updating the "),i("strong",[e._v("View")]),e._v(", based upon its own and the "),i("strong",[e._v("Model's")]),e._v(" rules. However, depending on the actual implementation, there is an intrinsic lack of a "),i("em",[e._v("Single source of truth")]),e._v(" - the "),i("strong",[e._v("View-Model")]),e._v(" can send out multiple independent events to the "),i("strong",[e._v("View")]),e._v(" for it to update, and it can be hard for the "),i("strong",[e._v("View")]),e._v(" to be reconstituted, or for a previous state to be reinstated. The MVI - Model-View-Intent (more info "),i("a",{attrs:{href:"https://medium.com/huawei-developers/stateful-android-apps-with-mvi-architecture-model-view-intent-d106b09bd967",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),i("OutboundLink")],1),e._v(") - pattern tries to improve on this, having a class being responsible for maintaining the state of the view")]),e._v(" "),i("p",[e._v("Another part where MVVM improves upon previous patterns is that it further decouples the 3 elements - the "),i("strong",[e._v("Model")]),e._v(" and "),i("strong",[e._v("View-Model")]),e._v(" each expose observable sources of data which the "),i("strong",[e._v("View-Model")]),e._v(" and "),i("strong",[e._v("View")]),e._v(" respectively connect to. Interfaces are also used to allow injecting the corresponding "),i("strong",[e._v("Model")]),e._v(" and "),i("strong",[e._v("View-Model")]),e._v(" implementations, which also improve on isolating specific elements of the application and allows for writting actual "),i("em",[e._v("unitary")]),e._v(" tests. All this decoupling and interface usage means that the actual implementations have to be provided in some manner - which is a good enough excuse to talk about dependency injection, on the next page:)")])])}),[],!1,null,null,null);t.default=o.exports}}]);