(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{469:function(e,t,n){"use strict";n.r(t);var i=n(45),a=Object(i.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"dependency-injection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dependency-injection"}},[e._v("#")]),e._v(" Dependency Injection")]),e._v(" "),n("h2",{attrs:{id:"intro"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#intro"}},[e._v("#")]),e._v(" Intro")]),e._v(" "),n("p",[n("strong",[e._v("Dependency Injection")]),e._v(" "),n("em",[e._v("(DI)")]),e._v(" is a technique used in software engineering in order to provide the parameters necessary for your bit of code to function. Before we get too deep into the topic, some vocabulary and term definition is probably in order. Starting off with the name itself:")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("Dependency: a dependency is reference one class has towards a another class, which is necessary for its execution. For example, a "),n("em",[e._v("Car")]),e._v(" class might need a reference to an "),n("em",[e._v("Engine")]),e._v(" class. These required classes are called dependencies, and in this example the "),n("em",[e._v("Car")]),e._v(" class is dependent on having an instance of the "),n("em",[e._v("Engine")]),e._v(" class to run.")])]),e._v(" "),n("li",[n("p",[e._v("Injection: the "),n("em",[e._v("injection")]),e._v(" part of "),n("em",[e._v("DI")]),e._v(" refers to how the dependencies are provided. In general, the ways this can be done are by having the class instantiate its dependencies on its own, getting them from somewhere else, or having it passed as a parameter (at the moment the class is created, or at a later moment). The third option is the "),n("em",[e._v("injection")]),e._v(" part")])])]),e._v(" "),n("p",[e._v("A slightly more in-depth explanation of all this can be found "),n("a",{attrs:{href:"https://developer.android.com/training/dependency-injection#fundamentals",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("p",[e._v("Now that we have a better idea of what dependency injection IS, let's take a look at WHAT we'll be using it for")]),e._v(" "),n("h2",{attrs:{id:"uses"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#uses"}},[e._v("#")]),e._v(" Uses")]),e._v(" "),n("p",[e._v("In practice, when we're discussing "),n("strong",[e._v("DI")]),e._v(", we're going to be using it for a few things:")]),e._v(" "),n("h3",{attrs:{id:"providing-constructor-parameters"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#providing-constructor-parameters"}},[e._v("#")]),e._v(" Providing constructor parameters:")]),e._v(" "),n("p",[e._v("Like explained above, this is the base use for "),n("strong",[e._v("DI")]),e._v(". We'll be finding this practically everywhere:")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("The most basic case is delegating the instantiation of parameters.")]),e._v(" "),n("ul",[n("li",[e._v("For instance, say we have multiple HTTP Clients, and we want to add to each one a interceptor which will log the requests in the console. Additionnally, we'll also want to not create multiple instances of that interceptor.")]),e._v(" "),n("li",[e._v("Without any "),n("strong",[e._v("DI")]),e._v(" we would have to manually handle on our own the instantiation of the interceptor, make sure we don't create multiple instances of it, and ideally only instance everything when we actually need it.")]),e._v(" "),n("li",[e._v("Obviously this is all very much doable, but it means additional code which has to be written for everything which is therefore prone to implementation errors.")])])]),e._v(" "),n("li",[n("p",[e._v("A slightly more advance use case, building on the one from above, and working along with the "),n("em",[e._v("SOLID")]),e._v(" principles (particularaly the Dependency Inversion Principle), we have the case where we want to instanciate the implementation of an interface.")]),e._v(" "),n("ul",[n("li",[e._v("For instance, we can have Service_A which requires an implementation of the Data_Repository_B interface.")]),e._v(" "),n("li",[e._v('If we have split up our code along Clean Architecture principles (which is what the previous "App Architecture" topic briefly describes), then that means that Service_A only has visibility on the Data_Repository_B interface - the actual implementation should be split off into a different module and should be of no concern to Service_A.')]),e._v(" "),n("li",[e._v("If we have done all that, then we have no direct way of knowing which implementation should be used, and therefore cannot create it on our own, as we could have done for the interceptors in the example above.")]),e._v(" "),n("li",[e._v("Without going into too much detail on the actual technical implementation just yet, in order to get around this conundrum, our "),n("strong",[e._v("DI")]),e._v(" framework will be responsible for determining which implementation to use, according to the configuration we wrote, instantiate it once or multiple times according to our needs, and provide it to the class which requires it. We'll get into the details a bit later on ðŸ˜‰.")])])]),e._v(" "),n("li",[n("p",[e._v("Finally, a nuance of the above use case is having the possibility of easily switching between implementations.")]),e._v(" "),n("ul",[n("li",[e._v("This can be quite handy for cases such as:\n"),n("ul",[n("li",[e._v("having an implementation which calls a webservice to recover data, and another one which uses local data (an offline database for instance, if the user does not have internet connectivity), or")]),e._v(" "),n("li",[e._v("when you want to isolate a specific component in order to be able to proper "),n("strong",[e._v("Unitary")]),e._v(" testing. Using the exemple from above, if we wanted to test various cases of Service_A and we required specific responses from Data_Repository_B, we could use a test implementation of the repository which returns the data which allows us to test out all the possible cases.")])])])])])]),e._v(" "),n("h2",{attrs:{id:"so-what-do-you-use"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#so-what-do-you-use"}},[e._v("#")]),e._v(" So, what do you use?")]),e._v(" "),n("p",[e._v("The most recommended Dependency Injection Framework is "),n("a",{attrs:{href:"https://dagger.dev/dev-guide/android.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Dagger"),n("OutboundLink")],1),e._v(". It is the industry standard, and provides most if not all of the tools required to answer to your needs. The only issue with implementing Dagger is the relatively steep learning curve and somewhat obscure error messages which sometimes makes debugging difficult. In order to address this issue and still keep all the benefits of the underlying engine, "),n("a",{attrs:{href:"https://dagger.dev/hilt/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Dagger-Hilt"),n("OutboundLink")],1),e._v(" was developped which greatly streamlines the setup process.")])])}),[],!1,null,null,null);t.default=a.exports}}]);